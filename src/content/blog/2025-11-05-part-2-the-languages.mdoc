---
title: "Part 2: The Languages"
author: Brian Shirai
date: 2025-11-05
order: 2
---

Posts in this series:

* [The Vivarium AI Experimentation Platform](/blog/2025-11-05-the-vivarium-ai-experimentation-platform/)
* [Part 1: The Agents](/blog/2025-11-05-part-1-the-agents/)
* [Part 2: The Languages](/blog/2025-11-05-part-2-the-languages/)
* [Part 3: The Tools](/blog/2025-11-05-part-3-the-tools/)
* [Part 4: The Infrastructure](/blog/2025-11-05-part-4-the-infrastructure/)
* [Part 5: The Roadmap](/blog/2025-11-05-part-5-the-roadmap/)

## What is in a Language?

Language is a fundamental aspect of intelligence. The particular form of the language is not nearly as important. But the concept of language, a syntax and grammar that carries meaning, is absolutely fundamental.

### Assertions

Every part of the system, from world to the description of the structure and function of agents to the tools agents can use needs an interface and the most powerful and efficient interface is an instance of a language.

Hence, language capabilities (i.e. form or syntax, semantics, parsers, compilers, etc) ore a fundamental element of an intelligent world.

Programmers tend to either view programming languages as handed down on stone tablets and hence you must be an adherent and religiously defend them, or something to go into the desert to create and bestow upon humanity to displace one of the existing religions.

This proposal takes a different perspective: Languages are somewhat mundane but still quite powerful tools and we'll make and use them as necessary.

By using "language" as the core interface between the components, the rigidity of something like a REST or gRPC API is avoided. One component could send the other a textual representation, a computation graph, or possibly just a pointer to the data structure that would result from the computation graph. **The potential power here is immense.**

### So What?

There are numerous reasons why making languages themselves a core component is controversial:

*. Language tech is extremely fragmented.
*. Most concerns about language focus on rather irrelevant syntax and sometimes on not-very-interesting semantics (e.g. Rust lifetimes and borrow checker).
*. Assumptions about "frontend", "middle-end", and "backend" limit the language tool chain unnecessarily.
*. Compiler writers, almost by definition, do not care about the applications. But in order to understand and utilize telemetry from the application in the compiler, the compiler must care about the application.
*. AI provides an ideal context to bring together "application" and "application telemetry" with the compiler machinery.

With languages as the core interface between components, the allowed semantics of the interaction can be formally verified and vary significantly according to the desired security posture.

### Pitch

The language capabilities will be crucial to the success of the system, but they will be discounted until that conclusion is unavoidable.

Application developers rarely think outside of two boxes: Polyglot (use the right language for the job), and Cyclops (Rust is the best language ever I'll never use anything else).

The polyglot perspective isn't generally aligned with the language goals here because it rarely permits anything other than an existing general purpose language (e.g. use JavaScript in the browser, use Go on the backend).

There are hence two ways to pitch the language technology to get some participation:

1. Pitch to Ruby and Python ecosystems that their language can be used to accomplish powerful things in this new developing AI ecosystem;
1. Pitch Vivarium with the language technology in a side-car and downplay a particular language.

Both pitches are concurrently viable, but the second will probably produce greater impact because despite there likely being less initial traction, the total population is much greater and stickiness once someone engages is much higher. New languages can be picked up. Completely rebuilding the system takes a lot more effort. And the benefits will be greater in the second case. Even if Rubinius is 10x faster than CRuby, it's still limited by the people who care anything about writing something in Ruby in the first place.

